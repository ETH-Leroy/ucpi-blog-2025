# W4 Visual Debugging

Author: Junzhe Tai

Debugging is a very common and unavoidable task for programmers. We typically use logging when dealing with software runtime analysis, explaining failures and crashes, and investigating user behaviors.In everyday development, we often face this situation: the program runs without errors, but the results are not what we expected. So we start adding print statements, setting breakpoints, tracking variables and so on. These methods are simple and effective, but interpreting the log output displayed in the console or terminal is often challenging. For example, log statements within loops can generate massive amounts of log information. Furthermore, log output is organized linearly based on the order of program execution, making it difficult to connect log statements in different locations. Programmers often adopt strategies, such as using spacing and special characters, give logs timestamps and contexts and so on. However, in order to better solve the pain points in debugging, more and more papers point to visual debugging.

**Introduction to visual debugging**
The core value of visual debugging lies in transforming abstract program states into graphical representations that conform to the laws of human visual perception, helping developers more efficiently identify "patterns" and "anomalies" in programs. According to Cognitive Load Theory, effective multimedia design can reduce extraneous load and allocate more cognitive resources to graph construction. This theory supports the long evolution from early algorithmic animations to modern AI-driven diagnostic tools.

**Pain points in debugging with logging**

There are roughly four pain points in current logging：

1.Logged Output Lacking a Meaningful Organization.
The lack of a meaningful organi zation in logs creates significant challenges when programmers try to understand logs. For example, When programmers insert logging statements in a loop to track variable changes, they often need to comment or un-comment other log statements in the program, scroll back and forth in the console panel to locate all related messages, or adjust the log output format to make messages of interest more distinctive.This is because programmers find it difficult to find useful information in a large amount of log output.

2.Data Structures Lacking Informative Visualizations and Interaction.
Modern browsers do keep arrays or JSON objects in expandable structures, but when these objects become deeply nested, the logs become unreadable. If you want to log the specific properties deep in the data structure, you need to switch back to the source code and write new log statements that can access the property. Interpreting numbers can also be challenging when it comes to position and dimensions. For example, a value like (250, 480) might represent a screen position—but how large is that position on the actual UI?

3.Loss of Context due to Frequent View Switching.
Debugging often means juggling between the console, the code editor, the webpage, and the DOM inspector. Each switch breaks concentration.This kind of view-switching makes it difficult to connect logs with their source, slowing down debugging and increasing cognitive load.

4.Trade-offs when Crafting and Interpreting Logs. Because logging is a temporary debugging tool, most developers don’t invest much effort in making logs clean or readable.

So our goals in visual debugging are:
1.Offering Meaningful and Informative Log Structures.
2.Supporting Interactive and Visual Logging.
3.Embedding Logs within Contexts.
4.Minimum Effort for the Desired Enhancements.

**Visual debugging tools: Log-it introduction**
We introduce a tool born to solve the above four pain points: Log-it. Log-it's core abstraction is a stream, which aggregates all log entries generated by the same log() statement at different times. Each stream has three parts: a header, a body, and a menu. The Stream Header can be dragged to relocate the Stream, and its crosshairs can be dragged to attach the Streams to page elements. The Stream Body hosts the log outputs produced by the log() statement. The Stream Menu offers a set of controls for the Stream, including Pause/Resume (to control the execution of each log() statement individually on the fly), Delete (only shown after the Stream is paused, to remove the Stream and disable the statement for the session), and Unfold/Collapse (to minimize the Stream to show only the latest output or unfold it to view all the logs). The menu also offers dynamic controls (e.g., for changing the output representation), when available, for different data types and structures of the logged items. Each Stream has three attributes that contribute to its advanced interpretability: Interactivity, Representation, and Context.

Interactivity (what ad hoc interactions the Stream offers for dynamic exploration)
Property Highlighting:
After expanding a complex object in the console, double-click a key to highlight that property. The header will display the property's index path within the object.

Synchronized Interaction:
When you expand, collapse, or highlight a property on a log entry, Log-it synchronizes the same operation to all other entries in the stream, allowing you to perform template operations on a single entry and broadcast them to the entire stream.

In-Place Sliding:
When you have a large history of entries, a linear list is difficult to compare. Log-it offers an "in-place sliding" mode: the interface only displays the current entry, and a slider (with timestamps) switches through the history. Changing values are highlighted with a light background, making changes more visible.

Representation (how the Stream is structured and visualized)
A Stream of number logs can be transformed into a horizontal bar plot using the shape button in the Stream menu.
The widths of the bars are the values in pixels.

When Area Filter is enabled, only the Streams attached to the elements overlapping with it will show.

The programmer can also switch between showing only the last shape or showing the entire history in a heat-map style.

Context (how the Stream is situated with page elements and links to the code)

The original code location is displayed here. This allows you to easily identify the source code snippet corresponding to the log entry without having to go back to the editor to check the line number.

Color Coding and Attach:

Each statement is assigned a default color, which can be manually overridden (.color()). The IDE synchronizes the colors displayed with the stream, making it easier to visually associate the statement.
You can drag a stream onto a page element (or .element('#id')), and the log will appear next to the element and update with scrolling. You will also trigger an element alert for errors.

**Future Work**
Future visual debugging systems can benefit from AI-driven log filtering, automatically highlighting relevant events and reducing noise in complex executions. In addition, customizable and user-adaptive visualizations can tailor debugging views to different users, tasks, and expertise levels. Finally, visual debugging can be extended to new domains such as VR and game design, where immersive, in-situ visualizations enable developers to understand system behavior directly within virtual environments.

**References**

[1] Shahnabati F, Sabourifard A, Amiri SH, Bosaghzadeh A, Ebrahimpour R. Cognitive load and visual attention assessment using physiological eye tracking measures in multimedia learning. PLoS One. 2025 Dec 1;20(12):e0337195. doi: 10.1371/journal.pone.0337195. PMID: 41325323; PMCID: PMC12668483.

[2] https://research.com/education/cognitive-theories-backing-the-use-of-visuals-in-educational-content

[3] Jiang, P., Sun, F., & Xia, H. (2023, April). Log-it: Supporting Programming with Interactive, Contextual, Structured, and Visual Logs. In Proceedings of the 2023 CHI Conference on Human Factors in Computing Systems (pp. 1-16).
